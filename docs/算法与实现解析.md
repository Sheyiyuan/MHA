# Metropolis–Hastings 算法原理与实现解析（MHA 项目）

本文从算法与工程实现两方面，系统解析本仓库中的 Metropolis–Hastings（MH）采样框架与两种提议分布实现：`GaussianMH` 与 `UniformMH`。

## 一、算法原理

- **目标**: 从难以直接采样的目标分布 `π(x)` 抽样，通常只需要未归一化密度 `π̃(x)`。
- **MH 接受概率**: 给定当前状态 `x` 和候选状态 `x'`，接受概率
  - 公式：$\alpha(x \to x') = \min\bigl(1, \frac{\pi(x')\,q(x\mid x')}{\pi(x)\,q(x'\mid x)}\bigr)$
  - 对数形式（数值更稳定）：$\log\alpha = \min\bigl(0, \log\pi(x') - \log\pi(x) + \log q(x\mid x') - \log q(x'\mid x)\bigr)$
- **对称提议分布**: 若 `q(x'|x) = q(x|x')`，则上式中的比值为 1，`log` 比为 0，接受概率简化为 $\min(1, \pi(x')/\pi(x))$。
- **燃烧期（Burn-in）**: 前若干步受初始值影响较大，常丢弃前 `10%` 左右的样本。
- **有效样本与相关性**: 马尔可夫链样本相关，必要时可做节流或链诊断；本仓库提供燃烧期后的样本获取接口。
- **调参经验**: 一般希望接受率处于约 `0.2~0.5` 区间，过小代表步子过大、过大代表探索不充分。

## 二、项目架构概览

```
MHA/
├── base.py            # 抽象基类：通用 MH 逻辑
├── gaussian.py        # 高斯提议分布的 MH 实现（连续、双峰示例）
├── uniform.py         # 均匀提议分布的 MH 实现（支持离散/连续）
├── __init__.py        # 包导出
├── readme.md          # 简要说明与示例
└── docs/算法与实现解析.md  # 本文档
```

核心为 `BaseMetropolisHastings`（`base.py`），子类仅需实现三件事：

- `target_log_prob(state)`: 目标分布的对数未归一化密度；
- `proposal_generate(current_state)`: 如何从当前状态产生候选；
- `proposal_log_prob_ratio(current, candidate)`: $\log\frac{q(current\mid candidate)}{q(candidate\mid current)}$（对称提议返回 0）。

### BaseMetropolisHastings 关键设计

- **初始化参数**: `param_dim`, `n_iter`, `burn_in(默认10%)`, `seed`；随机源使用 `numpy.random.Generator` 确保复现实验。
- **状态与记录**:
  - `current_state`: 当前链状态，默认 `N(0, I)` 初始化，可被子类覆盖；
  - `samples`: 大小为 `(n_iter, param_dim)` 的数组，记录每一步的状态；
  - `accept_flags`: 每步是否接受的布尔列表；
  - `acceptance_rate`: 运行结束后统计的总体接受率。
- **核心流程**:
  - `_step()`：生成候选 → 计算目标密度对数 → 计算接受概率 → 决定接受与否 → 记录；
  - `_compute_accept_prob()`：实现对数域下的 MH 接受率计算；
  - `run()`：循环 `_step()` 共 `n_iter` 次并计算接受率；
  - `get_effective_samples()`：返回燃烧期后的有效样本；
  - `get_summary()`：返回维度、迭代数、接受率、样本均值/方差等摘要。
- **复杂度**: 时间复杂度约为 `O(n_iter × param_dim)`；空间复杂度约为 `O(n_iter × param_dim)`。

## 三、具体实现解析

### 1) GaussianMH（`gaussian.py`）

- **使用场景**: 连续空间，示例目标是 1 维双峰分布。
- **目标分布（对数未归一化）**:
  - 代码：`-(x-2)^2/2 - (x+2)^2/8`，对应两个不同方差的高斯峰相加的对数型式（未归一化）。
- **提议分布**: 对称高斯随机游走：`x' = x + N(0, σ^2)`；参数 `proposal_sigma` 控制探索尺度。
- **对数提议比**: 对称 → 返回 `0.0`。
- **参数与调用**:
  - 关键参数：`param_dim=1`, `n_iter`, `burn_in`, `seed`, `proposal_sigma`；
  - 快速运行：`uv run ./gaussian.py`
- **调参建议**:
  - `proposal_sigma` 越大跳跃越远、接受率可能下降；越小探索慢、易困于单峰附近；
  - 关注 `get_summary()` 的 `acceptance_rate` 与样本统计，必要时调整迭代数与步长。

### 2) UniformMH（`uniform.py`）

- **使用场景**: 离散或连续空间；示例为骰子（离散 1–6）。
- **目标分布**: 通过函数注入 `target_log_prob: Callable[[np.ndarray], float]` 提供，便于复用与定制。
- **提议分布**: 在当前状态的每个维度上，按均匀分布在 `[−step_size, +step_size]` 范围内扰动：`x' = x + U(−s, s)`；
  - 若被识别为离散问题（见下），候选将四舍五入到整数。
- **状态约束**: 可选 `state_validator(state) -> bool`；
  - 在 `proposal_generate()` 中最多重采样 5 次以满足约束；
  - 在 `_init_state()` 中最多尝试 100 次生成有效初始值。
- **离散识别与存储**:
  - 若 `state_validator(current_state)` 在构造阶段通过检查，则将 `samples` 转为 `int` 类型，以整数存储并在提议后取整；
  - 注意：离散识别依赖构造期的轻量检测与守护（`try/except`），如初始化时验证器无法判断，将继续以浮点存储；
  - `_init_state()` 对离散情形采用 `[-5, 5]` 的整型均匀初始化作为保守默认（若约束更严格，建议自定义初始化逻辑）。
- **扩展摘要**: `get_summary()` 在 1 维离散情形汇报各状态出现频率（燃烧期后）。
- **示例**（骰子分布、`step_size=1` 便于相邻跳转）：
  ```python
  mh = UniformMH(
      target_log_prob=dice_target_log_prob,
      step_size=1,
      param_dim=1,
      n_iter=10000,
      burn_in=1000,
      seed=42,
      state_validator=dice_state_validator,
  )
  mh.run()
  print(mh.get_summary())
  ```

## 四、如何自定义与扩展

- **非对称提议**: 在子类中正确实现 `proposal_log_prob_ratio(current, candidate)`；
  - 例如独立提议或含漂移项的 Langevin 提议；
  - 记得使用对数形式避免下溢：返回 `log q(current|candidate) − log q(candidate|current)`。
- **高维参数**: 设定 `param_dim > 1`，在目标函数与提议生成中按向量处理；
- **自定义初始化**: 覆盖 `_init_state()`，结合先验或约束产生更合理的初始状态；
- **结果统计**: 覆盖 `get_summary()` 增加更丰富诊断（如自相关、分位数、分量边际统计等）。

## 五、快速上手与运行

- **环境依赖**: 见 `requirements.txt`（若为空则 `numpy` 即可）。推荐使用 `uv` 或 `pip` 安装。

```zsh
# 方式一：使用 uv（若你已安装）
uv run ./gaussian.py
uv run ./uniform.py

# 方式二：使用 venv + pip
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
python gaussian.py
python uniform.py
```

## 六、验证与诊断

- **接受率**: 通过 `get_summary()['acceptance_rate']` 观察，过低或过高都可能需要调参；
- **轨迹与直方图**: 可将 `get_effective_samples()` 可视化（时间序列、直方图、核密度等）；
- **随机种子**: 通过 `seed` 控制复现；
- **离散任务提示**: 若需要严格离散存储与提议，请确保构造期的 `state_validator` 能在初值附近返回 `True`，以触发整型存储与取整逻辑。

## 七、API 速览

- `BaseMetropolisHastings(param_dim, n_iter=10000, burn_in=None, seed=42)`
  - 需子类实现：`target_log_prob(state)`, `proposal_generate(current_state)`, `proposal_log_prob_ratio(current, candidate)`
  - 主要方法：`run()`, `get_effective_samples()`, `get_summary()`
- `GaussianMH(proposal_sigma=1.0, **kwargs)`
- `UniformMH(target_log_prob, step_size, param_dim, state_validator=None, **kwargs)`

## 八、常见问题（FAQ）

- 接受率始终很低？
  - 降低步长（`proposal_sigma` 或 `step_size`），或检查目标函数尺度；
- 样本几乎不动？
  - 增大步长或迭代次数，检查是否陷入单峰；
- 离散问题取整不生效？
  - 确保构造期验证器可在初始状态附近返回 `True`，或自行覆盖 `_init_state()` 与提议逻辑；
- 非对称提议怎么写？
  - 正确实现 `proposal_log_prob_ratio`，并在计算中使用对数形式以稳定数值。

—— 完 ——
